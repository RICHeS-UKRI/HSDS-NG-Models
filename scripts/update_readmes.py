#!/usr/bin/env python3
import os
from pathlib import Path
import re
from typing import List, Dict, Optional, Tuple

REPO_ROOT = Path(__file__).resolve().parents[1]
MODELS_DIR = REPO_ROOT / "models"
# Mermaid file generated by the workflow for the overall ng_models
NG_MERMAID_FILE = MODELS_DIR / "ng_models_mermaid.mmd"

VERSION_RE = re.compile(r"_v(\d+(?:\.\d+)*)\.tsv$")


def parse_version(filename: str) -> Optional[Tuple[int, ...]]:
    """
    Extract version tuple from a filename like 'sample_model_v1.2.tsv' -> (1, 2)
    """
    m = VERSION_RE.search(filename)
    if not m:
        return None
    parts = m.group(1).split(".")
    try:
        return tuple(int(p) for p in parts)
    except ValueError:
        return None


def find_ng_models_latest(tsvs: List[Path]) -> Optional[Path]:
    """
    Given a list of Paths to ng_models_v*.tsv files, return the latest by version.
    """
    versions = []
    for p in tsvs:
        v = parse_version(p.name)
        if v is not None:
            versions.append((v, p))
    if not versions:
        return None
    versions.sort(reverse=True, key=lambda vp: vp[0])
    return versions[0][1]


def discover_models() -> Dict[str, List[Path]]:
    """
    Discover model folders under models/ and collect versioned TSVs.
    Returns dict: {model_folder_name: [list of .tsv Paths]}
    """
    models: Dict[str, List[Path]] = {}
    if not MODELS_DIR.exists():
        return models

    for child in MODELS_DIR.iterdir():
        if child.is_dir():
            tsvs = sorted(child.glob("*_v*.tsv"))
            if tsvs:
                models[child.name] = tsvs
    return models


def model_title_from_folder(folder_name: str) -> str:
    """
    Turn 'samples' into 'Samples Model' etc. Simple heuristic – adjust if needed.
    """
    base = folder_name.replace("_", " ").strip()
    return base[:1].upper() + base[1:] + " Model"


def build_dynamic_modeller_url(raw_base: str, rel_path: Path) -> str:
    """
    Build the dynamic modeller URL from the raw GitHub URL to the TSV file.
    """
    raw_url = f"{raw_base}/{rel_path.as_posix()}"
    return (
        "https://research.nationalgallery.org.uk/lab/modelling/?url="
        + raw_url
    )


def read_mermaid_block() -> str:
    """
    Read the mermaid code for the overall ng_models file if present.
    """
    if NG_MERMAID_FILE.exists():
        text = NG_MERMAID_FILE.read_text(encoding="utf-8").strip()
        if text:
            return f"```mermaid\n{text}\n```\n"
    return "_Mermaid diagram not available yet._\n"


def generate_model_details_block(
    model_name: str,
    tsv_files: List[Path],
    raw_base: str,
) -> str:
    """
    Generate the <details> block with the version table for a single model.
    """
    # Sort versions descending
    version_info = []
    for p in tsv_files:
        v = parse_version(p.name)
        if v is not None:
            version_info.append((v, p))
    version_info.sort(reverse=True, key=lambda vp: vp[0])

    if not version_info:
        return ""

    latest_version, latest_path = version_info[0]
    latest_version_str = ".".join(str(x) for x in latest_version)
    latest_url = build_dynamic_modeller_url(raw_base, latest_path.relative_to(REPO_ROOT))

    lines = []
    lines.append("<details>")
    lines.append(
        f"<summary>{model_name}: "
        f'<a href="{latest_url}">{latest_version_str}</a>'
        f"</summary>\n"
    )
    lines.append(f"## {model_name} Details\n")
    lines.append("| | Date | Author | Model | Comment |")
    lines.append("| :-----------: | :-----------: | :-----------: | :-----------: | ----------- |")

    # Latest version row with a tick – you can later populate Date/Author/Comment manually if you want
    for idx, (ver_tuple, path) in enumerate(version_info):
        version_str = ".".join(str(x) for x in ver_tuple)
        url = build_dynamic_modeller_url(raw_base, path.relative_to(REPO_ROOT))
        status = ":heavy_check_mark:" if idx == 0 else ""
        # Date/Author/Comment left blank for now
        lines.append(
            f"| {status} |  |  | "
            f"[{version_str}]({url}) |  |"
        )

    # Spacer row for layout (optional)
    lines.append(
        "| | <img width=325 /> |<img width=175 /> | <img width=60 /> | <img width=500 /> |"
    )
    lines.append("</details>\n")

    return "\n".join(lines)


def write_top_readme(models: Dict[str, List[Path]], raw_base: str, ng_latest: Optional[Path]):
    """
    Generate the top-level README.md
    """
    mermaid_block = read_mermaid_block()

    lines = []
    lines.append("# CIDOC CRM-based models for paintings and samples\n")
    lines.append(
        "This repository collects semantic models (as simple TSV triples) for use with "
        "the National Gallery Dynamic Modeller and integration into ResearchSpace.\n"
    )

    if ng_latest:
        rel_ng = ng_latest.relative_to(REPO_ROOT)
        ng_url = build_dynamic_modeller_url(raw_base, rel_ng)
        lines.append("## Overall NG Models\n")
        lines.append(
            "The current NG-wide model can be explored directly in the Dynamic Modeller:\n\n"
        )
        lines.append(f"- [Open in Dynamic Modeller]({ng_url})\n")
        lines.append("\n### Mermaid overview\n\n")
        lines.append(mermaid_block)
    else:
        lines.append("## Overall NG Models\n")
        lines.append(
            "No `ng_models_v*.tsv` file has been detected in the `models/` folder yet.\n"
        )

    if models:
        lines.append("## Models\n")
        lines.append(
            "The following models are defined under the `models/` folder. "
            "Each section lists the available versions and links into the Dynamic Modeller.\n"
        )

        # Generate blocks in alphabetical order of folder name
        for folder_name in sorted(models.keys()):
            model_title = model_title_from_folder(folder_name)
            tsvs = models[folder_name]
            block = generate_model_details_block(model_title, tsvs, raw_base)
            if block:
                lines.append(block)

    REPO_ROOT.joinpath("README.md").write_text("\n".join(lines), encoding="utf-8")


def write_models_readme(models: Dict[str, List[Path]]):
    """
    Generate a simple README.md in models/ explaining its role.
    """
    lines = []
    lines.append("# models\n")
    lines.append(
        "This folder contains the NG-wide model definitions and individual model folders.\n"
    )
    lines.append(
        "Each model is expressed as a versioned TSV file suitable for the National Gallery "
        "Dynamic Modeller.\n"
    )
    lines.append("\n## Contents\n")
    lines.append("- `ng_models_vX.Y.tsv`: global models relating different entities.")
    if models:
        lines.append("- Per-model folders:")
        for folder_name in sorted(models.keys()):
            lines.append(f"  - `{folder_name}/`")
    MODELS_DIR.joinpath("README.md").write_text("\n".join(lines), encoding="utf-8")


def write_per_model_readmes(models: Dict[str, List[Path]], raw_base: str):
    """
    Generate a README.md inside each model folder.
    """
    for folder_name, tsvs in models.items():
        folder_path = MODELS_DIR / folder_name
        model_title = model_title_from_folder(folder_name)
        block = generate_model_details_block(model_title, tsvs, raw_base)

        lines = []
        lines.append(f"# {model_title}\n")
        lines.append(
            "This folder contains versioned TSV definitions of the model, "
            "intended for use with the National Gallery Dynamic Modeller.\n"
        )
        if block:
            lines.append("## Versions\n")
            lines.append(block)

        folder_path.joinpath("README.md").write_text("\n".join(lines), encoding="utf-8")


def main():
    raw_base = os.environ.get("RAW_BASE")
    if not raw_base:
        raise SystemExit("RAW_BASE environment variable must be set to the raw GitHub base URL.")

    # Find ng_models tsvs at models/ level
    ng_tsvs = list(MODELS_DIR.glob("ng_models_v*.tsv"))
    ng_latest = find_ng_models_latest(ng_tsvs)

    models = discover_models()

    write_top_readme(models, raw_base, ng_latest)
    write_models_readme(models)
    write_per_model_readmes(models, raw_base)


if __name__ == "__main__":
    main()
